<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dot Battle</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: system-ui, sans-serif; display: grid; grid-template-columns: minmax(320px, 420px) 1fr; grid-template-rows: 1fr; height: 100vh; overflow: hidden; }
    body.fullscreen { grid-template-columns: 1fr; }
    body.fullscreen #controls,
    body.fullscreen #stats { display: none; }
    body.fullscreen #main { grid-template-rows: 1fr; }
    body.controls-collapsed { grid-template-columns: 56px 1fr; }
    #controls { padding: 16px; border-right: 1px solid #3334; display: grid; gap: 12px; align-content: start; min-height: 0; overflow: hidden; }
    #controls .controls-scroll { overflow-y: auto; overflow-x: hidden; min-height: 0; display: grid; gap: 12px; align-content: start; }
    body.controls-collapsed #controls { padding: 8px; }
    body.controls-collapsed #controls > :not(.control-bar) { display: none; }
    .control-bar { display: flex; gap: 8px; align-items: center; position: sticky; top: 0; z-index: 2; background: #0f141b; padding-bottom: 8px; }
    body.controls-collapsed .control-bar { padding-bottom: 0; }
    body.controls-collapsed .control-bar { flex-direction: column; }
    .control-bar button { width: 40px; height: 40px; padding: 0; border-radius: 10px; border: 1px solid #3334; background: #111827; color: inherit; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; font-size: 20px; }
    .control-bar button:focus-visible { outline: 2px solid #93c5fd; outline-offset: 2px; }
    .control-bar button:hover { background: #1f2937; }
    details { border: 1px solid #3334; border-radius: 6px; padding: 8px; }
    summary { cursor: pointer; font-weight: 600; }
    details > .section-body { display: grid; gap: 12px; margin-top: 10px; }
    #main { display: grid; grid-template-rows: auto minmax(0, 1fr); min-height: 0; position: relative; }
    #stats { padding: 8px 12px; display: flex; flex-wrap: wrap; gap: 6px 12px; align-items: center; background: #0f141b; border-bottom: 1px solid #3334; }
    #stats div { min-width: 132px; font-size: 13px; display: inline-flex; align-items: center; gap: 8px; cursor: pointer; }
    #stats button { background: none; border: 0; color: inherit; font: inherit; padding: 0; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; font-variant-numeric: tabular-nums; min-width: 132px; justify-content: flex-start; }
    .faction-swatch { font-size: 22px; }
    #stats .count { min-width: 5ch; text-align: left; }
    #stats button:focus-visible { outline: 2px solid #93c5fd; outline-offset: 2px; border-radius: 4px; }
    .info-tooltip { position: relative; display: inline-flex; align-items: center; gap: 6px; font-size: 14px; }
    #stats .info-tooltip button { min-width: 0; width: 36px; height: 36px; padding: 0; border: 1px solid #3334; border-radius: 999px; background: #111827; line-height: 1; cursor: help; font-size: 24px; display: inline-flex; align-items: center; justify-content: center; }
    .info-tooltip button:focus-visible { outline: 2px solid #93c5fd; outline-offset: 2px; }
    .info-tooltip span { position: absolute; right: 0; top: 28px; width: 300px; padding: 10px 12px; border-radius: 6px; background: #0f141b; border: 1px solid #3334; font-size: 13px; color: inherit; box-shadow: 0 4px 12px #0008; opacity: 0; pointer-events: none; transition: opacity 0.12s ease; }
    .info-tooltip button:hover + span,
    .info-tooltip button:focus-visible + span { opacity: 1; }
    #canvas { display: block; width: 100%; height: 100%; background: #0b0f14; }
    #dotMenu { position: absolute; display: none; background: #0f141b; border: 1px solid #3334; border-radius: 6px; padding: 10px; z-index: 5; min-width: 160px; }
    #dotMenu label { font-size: 12px; }
    #dotMenu .row { margin-right: 0; }
    #dotColorWrap { position: relative; }
    #dotColorButton { width: 56px; height: 28px; border: 1px solid #3334; border-radius: 4px; background: #111827; cursor: pointer; }
    #dotColorButton:focus-visible { outline: 1px solid #93c5fd; outline-offset: 2px; }
    #dotColorList { position: absolute; top: 32px; left: 0; display: none; grid-template-columns: repeat(4, 16px); gap: 6px; padding: 6px; border: 1px solid #3334; border-radius: 6px; background: #0f141b; z-index: 6; }
    .dot-color-swatch { width: 16px; height: 16px; border: 0; padding: 0; border-radius: 3px; cursor: pointer; }
    .dot-color-swatch:hover { filter: none; }
    .dot-color-swatch:focus-visible { outline: 1px solid #93c5fd; outline-offset: 2px; }
    .palette-editor { display: grid; gap: 10px; }
    .palette-rows { display: grid; gap: 8px; }
    .palette-row { display: grid; grid-template-columns: auto 1fr auto auto; gap: 8px; align-items: center; }
    .palette-color { width: 36px; height: 28px; padding: 0; border: 1px solid #3334; border-radius: 4px; background: #111827; cursor: pointer; }
    .palette-hex { font-size: 12px; opacity: 0.8; }
    .palette-actions { display: flex; flex-wrap: wrap; gap: 8px; }
    .icon-button { width: 34px; height: 34px; padding: 0; border-radius: 8px; border: 1px solid #3334; background: #111827; color: inherit; display: inline-flex; align-items: center; justify-content: center; cursor: pointer; font-size: 18px; line-height: 1; }
    .icon-button:hover { background: #1f2937; }
    .icon-button:focus-visible { outline: 2px solid #93c5fd; outline-offset: 2px; }
    .mini-button { padding: 4px 8px; border-radius: 6px; border: 1px solid #3334; background: #111827; color: inherit; cursor: pointer; font-size: 12px; }
    .mini-button:hover { background: #1f2937; }
    .mini-button:focus-visible { outline: 2px solid #93c5fd; outline-offset: 2px; }
    #paletteInput { width: 100%; resize: vertical; min-height: 60px; }
    label { display: grid; gap: 6px; font-size: 14px; }
    input[type="range"] { width: 100%; }
    button { padding: 8px 12px; }
    .row { display: flex; gap: 8px; align-items: center; margin-right: 16px; }
    .value { min-width: 48px; text-align: right; font-variant-numeric: tabular-nums; margin-right: 16px; }
  </style>
</head>
<body>
    <section id="controls">
      <div class="control-bar">
        <button id="controlsToggle" type="button" aria-label="Settings" title="Settings" aria-expanded="true">‚öô</button>
        <button id="restart" type="button" aria-label="Restart" title="Restart">‚Üª</button>
        <button id="pause" type="button" aria-label="Pause" title="Pause">‚è∏</button>
        <button id="fullscreen" type="button" aria-label="Fullscreen" title="Fullscreen">‚õ∂</button>
      </div>
      <div class="controls-scroll">
        <details open>
          <summary>Variables</summary>
          <div class="section-body">
          <label>Speed
            <div class="row"><input id="speed" type="range" min="5" max="300" step="5" value="60"><span id="speedVal" class="value"></span></div>
          </label>
          <label>Battle radius
            <div class="row"><input id="battleRadius" type="range" min="0" max="20" step="1" value="5"><span id="battleRadiusVal" class="value"></span></div>
          </label>
          <label id="magnetStrengthWrap">Magnet strength
            <div class="row"><input id="magnetStrength" type="range" min="0" max="200" step="5" value="80"><span id="magnetStrengthVal" class="value"></span></div>
          </label>
          <label>Mouse attraction power
            <div class="row"><input id="mouseAttraction" type="range" min="-1" max="1" step="0.05" value="0"><span id="mouseAttractionVal" class="value"></span></div>
          </label>
          <label>Mouse attraction range
            <div class="row"><input id="mouseRange" type="range" min="100" max="500" step="10" value="150"><span id="mouseRangeVal" class="value"></span></div>
          </label>
          <label class="row"><input id="repelAll" type="checkbox">Repel all colors</label>
        </div>
        </details>
        <details>
          <summary>Setup</summary>
          <div class="section-body">
          <label>Dots
            <div class="row"><input id="count" type="range" min="100" max="2000" step="10" value="500"><span id="countVal" class="value"></span></div>
          </label>
          <label>Min size
            <div class="row"><input id="minSize" type="range" min="2" max="10" step="1" value="2"><span id="minSizeVal" class="value"></span></div>
          </label>
          <label>Max size
            <div class="row"><input id="maxSize" type="range" min="4" max="20" step="1" value="6"><span id="maxSizeVal" class="value"></span></div>
          </label>
          <div class="palette-editor" aria-label="Palette editor">
            <div class="palette-rows" id="paletteRows"></div>
          <div class="palette-actions">
            <button id="addColor" class="icon-button" type="button" aria-label="Add color" title="Add color">+</button>
            <button id="clearPalette" class="icon-button" type="button" aria-label="Remove all colors" title="Remove all colors">üóë</button>
            <button id="randomizePalette" class="icon-button" type="button" aria-label="Randomize palette" title="Randomize palette">üé≤</button>
            <button id="resetPalette" class="icon-button" type="button" aria-label="Reset palette" title="Reset palette">‚Ü∫</button>
          </div>
          <label>Palette name
            <input id="paletteName" type="text" placeholder="My palette">
          </label>
          <div class="palette-actions">
            <button id="savePalette" type="button">Save favorite</button>
            <button id="exportPalette" type="button">Copy JSON</button>
          </div>
          <label>Favorites
            <select id="paletteFavorites"></select>
          </label>
          <div class="palette-actions">
            <button id="loadFavorite" type="button">Load favorite</button>
            <button id="deleteFavorite" type="button">Delete favorite</button>
          </div>
          <label>Load palette
            <textarea id="paletteInput" placeholder='["#ff0000", "#00ff00"] or ff0000 00ff00'></textarea>
          </label>
            <button id="loadPalette" type="button">Load from palette</button>
          </div>
          </div>
        </details>
      </div>
    </section>
  <section id="main">
    <div id="stats"></div>
    <canvas id="canvas"></canvas>
    <div id="dotMenu" role="dialog" aria-hidden="true">
      <label>Size
        <div class="row"><input id="dotSize" type="range" min="1" max="20" step="1" value="8"><span id="dotSizeVal"
            class="value"></span></div>
      </label>
      <label>Color
        <div class="row" id="dotColorWrap">
          <button id="dotColorButton" type="button"></button>
          <div id="dotColorList" role="listbox" aria-label="Dot color"></div>
        </div>
      </label>
    </div>
  </section>
  <script type="module">
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
            const dotMenu = document.getElementById('dotMenu');
            const dotSizeInput = document.getElementById('dotSize');
            const dotSizeVal = document.getElementById('dotSizeVal');
    const dotColorButton = document.getElementById('dotColorButton');
    const dotColorList = document.getElementById('dotColorList');
    const controlsToggle = document.getElementById('controlsToggle');
    const paletteRows = document.getElementById('paletteRows');
    const addColorButton = document.getElementById('addColor');
    const clearPaletteButton = document.getElementById('clearPalette');
    const randomizePaletteButton = document.getElementById('randomizePalette');
    const resetPaletteButton = document.getElementById('resetPalette');
    const loadPaletteButton = document.getElementById('loadPalette');
    const paletteInput = document.getElementById('paletteInput');
    const paletteNameInput = document.getElementById('paletteName');
    const savePaletteButton = document.getElementById('savePalette');
    const exportPaletteButton = document.getElementById('exportPalette');
    const favoritesSelect = document.getElementById('paletteFavorites');
    const loadFavoriteButton = document.getElementById('loadFavorite');
    const deleteFavoriteButton = document.getElementById('deleteFavorite');
    const controls = {
      count: document.getElementById('count'),
      speed: document.getElementById('speed'),
      minSize: document.getElementById('minSize'),
      maxSize: document.getElementById('maxSize'),
      battleRadius: document.getElementById('battleRadius'),
      magnetStrength: document.getElementById('magnetStrength'),
      mouseAttraction: document.getElementById('mouseAttraction'),
      mouseRange: document.getElementById('mouseRange'),
      repelAll: document.getElementById('repelAll'),
      restart: document.getElementById('restart'),
      pause: document.getElementById('pause'),
      fullscreen: document.getElementById('fullscreen'),
    };
    const valueEls = {
      count: document.getElementById('countVal'),
      speed: document.getElementById('speedVal'),
      minSize: document.getElementById('minSizeVal'),
      maxSize: document.getElementById('maxSizeVal'),
      battleRadius: document.getElementById('battleRadiusVal'),
      magnetStrength: document.getElementById('magnetStrengthVal'),
      mouseAttraction: document.getElementById('mouseAttractionVal'),
      mouseRange: document.getElementById('mouseRangeVal'),
    };

    function updateValues() {
      for (const key of Object.keys(valueEls)) {
        if (key === 'mouseAttraction') {
          valueEls[key].textContent = Number(controls[key].value).toFixed(2);
        } else {
          valueEls[key].textContent = controls[key].value;
        }
      }
      const repelAll = controls.repelAll.checked;
    }
    updateValues();
    Object.values(controls).forEach((el) => {
      if (el?.addEventListener) {
        el.addEventListener('input', updateValues);
      }
    });

    let viewWidth = 0;
    let viewHeight = 0;
    let fullscreen = false;
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      let width = 0;
      let height = 0;
      if (fullscreen) {
        width = window.innerWidth;
        height = window.innerHeight + 5;
        canvas.style.width = `${width}px`;
        canvas.style.height = `${height}px`;
      } else {
        const rect = canvas.getBoundingClientRect();
        width = rect.width;
        height = rect.height;
        canvas.style.width = '';
        canvas.style.height = '';
      }
      viewWidth = width;
      viewHeight = height;
      canvas.width = Math.round(width * dpr);
      canvas.height = Math.round(height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    requestAnimationFrame(resizeCanvas);
    const resizeObserver = new ResizeObserver(() => {
      resizeCanvas();
      needsRender = true;
    });
    resizeObserver.observe(canvas);

    const defaultPalette = [
      '#dc143c',            // red (dark)
      '#ff7a00',            // orange
      '#FFFF00',            // yellow
      '#7fff00',            // chartreuse
      '#00ffff',            // aqua
      '#0000ff',            // blue
      '#7b1fa2',            // purple (dark)
      '#ffffff'             // white
    ];
    let palette = [...defaultPalette];
    function normalizeHex(raw) {
      if (!raw) return null;
      const cleaned = raw.trim().replace(/^#/, '');
      if (!/^[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/.test(cleaned)) return null;
      const hex = cleaned.length === 3
        ? cleaned.split('').map((c) => c + c).join('')
        : cleaned;
      return `#${hex.toLowerCase()}`;
    }
    function hsvToHex(h, s, v) {
      const c = v * s;
      const hh = (h % 360) / 60;
      const x = c * (1 - Math.abs((hh % 2) - 1));
      let r = 0;
      let g = 0;
      let b = 0;
      if (hh >= 0 && hh < 1) [r, g, b] = [c, x, 0];
      else if (hh < 2) [r, g, b] = [x, c, 0];
      else if (hh < 3) [r, g, b] = [0, c, x];
      else if (hh < 4) [r, g, b] = [0, x, c];
      else if (hh < 5) [r, g, b] = [x, 0, c];
      else [r, g, b] = [c, 0, x];
      const m = v - c;
      const toHex = (value) => Math.round((value + m) * 255).toString(16).padStart(2, '0');
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }
    function randomizePalette() {
      const count = Math.floor(rand(4, 9));
      const hueStep = 360 / count;
      const baseHue = rand(0, 360);
      const colors = [];
      for (let i = 0; i < count; i++) {
        const hue = (baseHue + hueStep * i + rand(-12, 12) + 360) % 360;
        const saturation = rand(0.55, 0.9);
        const value = rand(0.65, 0.95);
        colors.push(hsvToHex(hue, saturation, value));
      }
      applyPalette(colors);
    }
    function parsePaletteInput(text) {
      if (!text) return [];
      try {
        const parsed = JSON.parse(text);
        if (Array.isArray(parsed)) {
          return parsed.map((entry) => normalizeHex(String(entry))).filter(Boolean);
        }
      } catch (error) {
        // Ignore JSON parse errors and try token parsing instead.
      }
      return text
        .split(/[\s,]+/)
        .map((token) => normalizeHex(token))
        .filter(Boolean);
    }
    const favoritesStorageKey = 'dotbattle.paletteFavorites';
    function getFavorites() {
      try {
        const stored = JSON.parse(localStorage.getItem(favoritesStorageKey) || '[]');
        return Array.isArray(stored) ? stored : [];
      } catch (error) {
        return [];
      }
    }
    function saveFavorites(favorites) {
      localStorage.setItem(favoritesStorageKey, JSON.stringify(favorites));
    }
    function refreshFavoritesSelect(favorites = getFavorites()) {
      favoritesSelect.innerHTML = favorites.map((fav, index) => (
        `<option value="${index}">${fav.name}</option>`
      )).join('');
    }
    function getFactionColor(faction) {
      if (!palette.length) return '#111827';
      return palette[faction % palette.length];
    }
    function updateDotColorList() {
      dotColorList.innerHTML = palette.map((color, index) => (
        `<button type="button" class="dot-color-swatch" data-color="${index}" style="background:${color}" aria-label="Color ${index + 1}"></button>`
      )).join('');
    }
    function renderPaletteEditor() {
      paletteRows.innerHTML = palette.map((color, index) => (
        `<div class="palette-row">
          <input type="color" class="palette-color" data-index="${index}" value="${color}" aria-label="Color ${index + 1}">
          <span class="palette-hex">${color}</span>
          <button type="button" class="mini-button palette-add-dots" data-index="${index}" aria-label="Add 50 dots for color ${index + 1}">+50</button>
          <button type="button" class="icon-button palette-remove" data-index="${index}" aria-label="Remove color ${index + 1}" title="Remove color ${index + 1}">üóë</button>
        </div>`
      )).join('');
      updateDotColorList();
    }
    function applyPalette(nextPalette) {
      palette = nextPalette;
      if (!palette.length) {
        dots.length = 0;
        dotMenu.style.display = 'none';
        dotColorList.style.display = 'none';
        menuDot = null;
      } else {
        for (const dot of dots) {
          dot.faction = dot.faction % palette.length;
        }
        if (menuDot) {
          menuDot.faction = menuDot.faction % palette.length;
          dotColorButton.style.background = getFactionColor(menuDot.faction);
        }
      }
      renderPaletteEditor();
    }
    renderPaletteEditor();
    refreshFavoritesSelect();

    let dots = [];
    let paused = false;
    let lastTime = 0;
    let gridCells = [];
    let nextStatsUpdate = 0;
    let lastFrameTime = 0;
    let fps = 0;
    let mouse = { x: 0, y: 0, active: false };
            let menuDot = null;
    let hoverDot = null;
    let lastSimulationTime = 0;
    let needsRender = true;
    let targetFps = 60;

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    const arenaPadding = { top: 12, right: 12, bottom: 20, left: 12 };
    function spawnDot(faction, x, y, minSize, maxSize) {
      const size = rand(minSize, maxSize);
      const angle = rand(0, Math.PI * 2);
      const speed = rand(0.4, 1.0);
      return {
        x,
        y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        size,
        faction,
      };
    }
    function init() {
      const count = Number(controls.count.value);
      const minSize = Number(controls.minSize.value);
      const maxSize = Number(controls.maxSize.value);
      const factions = palette.length;
      const width = viewWidth;
      const height = viewHeight;
      if (!factions) {
        dots = [];
        return;
      }
      dots = new Array(count).fill(0).map(() => {
        return {
          ...spawnDot(
            Math.floor(rand(0, factions)),
            rand(arenaPadding.left, width - arenaPadding.right),
            rand(arenaPadding.top, height - arenaPadding.bottom),
            minSize,
            maxSize
          ),
        };
      });
    }
    function exitFullscreen() {
      fullscreen = false;
      document.body.classList.remove('fullscreen');
      requestAnimationFrame(() => {
        resizeCanvas();
        requestAnimationFrame(() => {
          resizeCanvas();
          needsRender = true;
        });
      });
    }

    function update(dt) {
      const speedScale = Number(controls.speed.value) / 100;
      const battleRadius = Number(controls.battleRadius.value);
      if (battleRadius <= 0) {
        const repelAll = controls.repelAll.checked;
        const magnetStrength = Number(controls.magnetStrength.value) / 100;
        const mouseAttraction = Number(controls.mouseAttraction.value) * 3;
        const influenceRadius = Math.max(8, Number(controls.maxSize.value) * 5);
        const influenceRadiusSq = influenceRadius * influenceRadius;
        const mouseInfluenceRadius = Number(controls.mouseRange.value);
        const mouseInfluenceRadiusSq = mouseInfluenceRadius * mouseInfluenceRadius;
        const width = viewWidth;
        const height = viewHeight;
        const padding = fullscreen ? arenaPadding : arenaPadding;
        const minX = padding.left;
        const minY = padding.top;
        const maxX = width - padding.right;
        const maxY = height - padding.bottom;
        const cellSize = Math.max(8, influenceRadius);
        const cols = Math.ceil(width / cellSize);
        const rows = Math.ceil(height / cellSize);
        const cellCount = cols * rows;
        if (cellCount !== gridCells.length) {
          gridCells = new Array(cellCount).fill(null).map(() => []);
        } else {
          for (let i = 0; i < gridCells.length; i++) gridCells[i].length = 0;
        }
        for (const dot of dots) {
          const cx = Math.min(cols - 1, Math.max(0, Math.floor(dot.x / cellSize)));
          const cy = Math.min(rows - 1, Math.max(0, Math.floor(dot.y / cellSize)));
          gridCells[cx + cy * cols].push(dot);
        }
        for (const dot of dots) {
          let ax = 0;
          let ay = 0;
          const cx = Math.min(cols - 1, Math.max(0, Math.floor(dot.x / cellSize)));
          const cy = Math.min(rows - 1, Math.max(0, Math.floor(dot.y / cellSize)));
          for (let oy = -1; oy <= 1; oy++) {
            for (let ox = -1; ox <= 1; ox++) {
              const nx = cx + ox;
              const ny = cy + oy;
              if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
              const neighborCell = gridCells[nx + ny * cols];
              if (!neighborCell.length) continue;
              for (const other of neighborCell) {
                if (other === dot) continue;
                const dx = other.x - dot.x;
                const dy = other.y - dot.y;
                const distSq = dx * dx + dy * dy;
                const sizeFactor = other.size / Number(controls.maxSize.value);
                const effectiveRadius = influenceRadius * (0.6 + sizeFactor);
                const effectiveRadiusSq = effectiveRadius * effectiveRadius;
                if (distSq === 0 || distSq > effectiveRadiusSq) continue;
                const dist = Math.sqrt(distSq);
                const dirX = dx / dist;
                const dirY = dy / dist;
                const falloff = 1 - dist / effectiveRadius;
                const force = magnetStrength * falloff * (0.5 + sizeFactor * sizeFactor);
                const sign = repelAll ? -1 : (other.faction === dot.faction ? -1 : 1);
                ax += dirX * force * sign;
                ay += dirY * force * sign;
              }
            }
          }
          dot.vx += ax * dt;
          dot.vy += ay * dt;
          const maxSpeed = 3;
          const speed = Math.hypot(dot.vx, dot.vy);
          if (speed > maxSpeed) {
            dot.vx = (dot.vx / speed) * maxSpeed;
            dot.vy = (dot.vy / speed) * maxSpeed;
          }
          if (!fullscreen && mouse.active && mouseAttraction !== 0) {
            const dx = mouse.x - dot.x;
            const dy = mouse.y - dot.y;
            const distSq = dx * dx + dy * dy;
            if (distSq > 0 && distSq <= mouseInfluenceRadiusSq) {
              const dist = Math.sqrt(distSq);
              const dirX = dx / dist;
              const dirY = dy / dist;
              const falloff = 1 - dist / mouseInfluenceRadius;
              const force = mouseAttraction * falloff;
              dot.vx += dirX * force * dt;
              dot.vy += dirY * force * dt;
            }
          }
          const wallRadius = Math.max(20, influenceRadius * 0.5);
          const wallStrength = 0.4;
          const bounceDamping = 0.6;
          const left = minX + dot.size;
          const right = maxX - dot.size;
          const top = minY + dot.size;
          const bottom = maxY - dot.size;
          const leftDist = dot.x - left;
          const rightDist = right - dot.x;
          const topDist = dot.y - top;
          const bottomDist = bottom - dot.y;
          if (leftDist < wallRadius) dot.vx += (1 - leftDist / wallRadius) * wallStrength * dt;
          if (rightDist < wallRadius) dot.vx -= (1 - rightDist / wallRadius) * wallStrength * dt;
          if (topDist < wallRadius) dot.vy += (1 - topDist / wallRadius) * wallStrength * dt;
          if (bottomDist < wallRadius) dot.vy -= (1 - bottomDist / wallRadius) * wallStrength * dt;
          const preX = dot.x;
          const preY = dot.y;
          dot.x += dot.vx * dt * speedScale;
          dot.y += dot.vy * dt * speedScale;
          if (dot.x <= left || dot.x >= right) dot.vx *= -bounceDamping;
          if (dot.y <= top || dot.y >= bottom) dot.vy *= -bounceDamping;
          dot.x = Math.max(left, Math.min(right, dot.x));
          dot.y = Math.max(top, Math.min(bottom, dot.y));
        }
        needsRender = true;
        return;
      }
      const repelAll = controls.repelAll.checked;
      const magnetStrength = Number(controls.magnetStrength.value) / 100;
      const mouseAttraction = Number(controls.mouseAttraction.value) * 3;
      const influenceRadius = Math.max(8, Number(controls.maxSize.value) * 5);
      const influenceRadiusSq = influenceRadius * influenceRadius;
      const mouseInfluenceRadius = Number(controls.mouseRange.value);
      const mouseInfluenceRadiusSq = mouseInfluenceRadius * mouseInfluenceRadius;
      const width = viewWidth;
      const height = viewHeight;
      const padding = arenaPadding;
      const minX = padding.left;
      const minY = padding.top;
      const maxX = width - padding.right;
      const maxY = height - padding.bottom;
      const cellSize = Math.max(8, influenceRadius);
      const cols = Math.ceil(width / cellSize);
      const rows = Math.ceil(height / cellSize);
      const cellCount = cols * rows;
      if (cellCount !== gridCells.length) {
        gridCells = new Array(cellCount).fill(null).map(() => []);
      } else {
        for (let i = 0; i < gridCells.length; i++) gridCells[i].length = 0;
      }

      for (const dot of dots) {
        const cx = Math.min(cols - 1, Math.max(0, Math.floor(dot.x / cellSize)));
        const cy = Math.min(rows - 1, Math.max(0, Math.floor(dot.y / cellSize)));
        gridCells[cx + cy * cols].push(dot);
      }

      for (const dot of dots) {
        let ax = 0;
        let ay = 0;
        const cx = Math.min(cols - 1, Math.max(0, Math.floor(dot.x / cellSize)));
        const cy = Math.min(rows - 1, Math.max(0, Math.floor(dot.y / cellSize)));
        for (let oy = -1; oy <= 1; oy++) {
          for (let ox = -1; ox <= 1; ox++) {
            const nx = cx + ox;
            const ny = cy + oy;
            if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
            const neighborCell = gridCells[nx + ny * cols];
            if (!neighborCell.length) continue;
            for (const other of neighborCell) {
              if (other === dot) continue;
              const dx = other.x - dot.x;
              const dy = other.y - dot.y;
              const distSq = dx * dx + dy * dy;
              const sizeFactor = other.size / Number(controls.maxSize.value);
              const effectiveRadius = influenceRadius * (0.6 + sizeFactor);
              const effectiveRadiusSq = effectiveRadius * effectiveRadius;
              if (distSq === 0 || distSq > effectiveRadiusSq) continue;
              const dist = Math.sqrt(distSq);
              const dirX = dx / dist;
              const dirY = dy / dist;
              const falloff = 1 - dist / effectiveRadius;
              const force = magnetStrength * falloff * (0.5 + sizeFactor * sizeFactor);
              const sign = repelAll ? -1 : (other.faction === dot.faction ? -1 : 1);
              ax += dirX * force * sign;
              ay += dirY * force * sign;
            }
          }
        }
        dot.vx += ax * dt;
        dot.vy += ay * dt;
        const maxSpeed = 3;
        const speed = Math.hypot(dot.vx, dot.vy);
        if (speed > maxSpeed) {
          dot.vx = (dot.vx / speed) * maxSpeed;
          dot.vy = (dot.vy / speed) * maxSpeed;
        }
        if (!fullscreen && mouse.active && mouseAttraction !== 0) {
          const dx = mouse.x - dot.x;
          const dy = mouse.y - dot.y;
          const distSq = dx * dx + dy * dy;
          if (distSq > 0 && distSq <= mouseInfluenceRadiusSq) {
            const dist = Math.sqrt(distSq);
            const dirX = dx / dist;
            const dirY = dy / dist;
            const falloff = 1 - dist / mouseInfluenceRadius;
            const force = mouseAttraction * falloff;
            dot.vx += dirX * force * dt;
            dot.vy += dirY * force * dt;
          }
        }
        const wallRadius = Math.max(20, influenceRadius * 0.5);
        const wallStrength = 0.4;
        const bounceDamping = 0.6;
        const left = minX + dot.size;
        const right = maxX - dot.size;
        const top = minY + dot.size;
        const bottom = maxY - dot.size;
        const leftDist = dot.x - left;
        const rightDist = right - dot.x;
        const topDist = dot.y - top;
        const bottomDist = bottom - dot.y;
        if (leftDist < wallRadius) dot.vx += (1 - leftDist / wallRadius) * wallStrength * dt;
        if (rightDist < wallRadius) dot.vx -= (1 - rightDist / wallRadius) * wallStrength * dt;
        if (topDist < wallRadius) dot.vy += (1 - topDist / wallRadius) * wallStrength * dt;
        if (bottomDist < wallRadius) dot.vy -= (1 - bottomDist / wallRadius) * wallStrength * dt;
        const preX = dot.x;
        const preY = dot.y;
        dot.x += dot.vx * dt * speedScale;
        dot.y += dot.vy * dt * speedScale;
        if (dot.x <= left || dot.x >= right) dot.vx *= -bounceDamping;
        if (dot.y <= top || dot.y >= bottom) dot.vy *= -bounceDamping;
        dot.x = Math.max(left, Math.min(right, dot.x));
        dot.y = Math.max(top, Math.min(bottom, dot.y));
      }

      if (battleRadius > 0) {
        const battleRadiusSq = battleRadius * battleRadius;
        for (let cy = 0; cy < rows; cy++) {
          for (let cx = 0; cx < cols; cx++) {
            const cell = gridCells[cx + cy * cols];
            if (!cell.length) continue;
            for (const dot of cell) {
              for (let oy = -1; oy <= 1; oy++) {
                for (let ox = -1; ox <= 1; ox++) {
                  const nx = cx + ox;
                  const ny = cy + oy;
                  if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
                  const neighborCell = gridCells[nx + ny * cols];
                  if (!neighborCell.length) continue;
                  for (const other of neighborCell) {
                    if (other === dot) continue;
                    if (other.faction === dot.faction) continue;
                    const dx = other.x - dot.x;
                    const dy = other.y - dot.y;
                    const distSq = dx * dx + dy * dy;
                    if (distSq <= battleRadiusSq) {
                      const dotWeight = dot.size * dot.size;
                      const otherWeight = other.size * other.size;
                      const total = dotWeight + otherWeight;
                      const roll = Math.random() * total;
                      if (roll < dotWeight) {
                        other.faction = dot.faction;
                      } else {
                        dot.faction = other.faction;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      needsRender = true;
    }

    function render() {
      const width = viewWidth;
      const height = viewHeight;
      const padding = arenaPadding;
      ctx.clearRect(0, 0, width, height);
      if (!fullscreen) {
        ctx.strokeStyle = '#1f2937';
        ctx.lineWidth = 2;
         ctx.strokeRect(
           padding.left,
           padding.top,
           width - padding.left - padding.right,
           height - padding.top - padding.bottom
         );
      }
      for (const dot of dots) {
        ctx.fillStyle = getFactionColor(dot.faction);
        ctx.beginPath();
        ctx.arc(dot.x, dot.y, dot.size, 0, Math.PI * 2);
        ctx.fill();
      }
      if (paused && hoverDot) {
        if (!dots.includes(hoverDot)) {
          hoverDot = null;
        } else {
          ctx.strokeStyle = 'limegreen';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(hoverDot.x, hoverDot.y, hoverDot.size + 2, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
    }

    function updateStats() {
      const factions = palette.length;
      const counts = new Array(factions).fill(0);
      for (const dot of dots) counts[dot.faction]++;
      const total = dots.length;
      const statsEl = document.getElementById('stats');
      if (statsEl.children.length !== factions + 3) {
        const factionButtons = counts.map((_, i) => (
          `<button type="button" data-faction="${i}"><span class="faction-swatch" style="color:${getFactionColor(i)}">‚ñ†</span><span class="count">0</span></button>`
        )).join('');
        statsEl.innerHTML = `${factionButtons}<div class="total"><strong>Total</strong> <span class="count">0</span></div><div class="fps"><strong>FPS</strong> <span class="count">0</span></div><div class="info-tooltip"><button type="button" aria-label="Faction controls info">i</button><span>Click a faction swatch to add 50 dots. Shift + click converts all dots to that faction. Right-click removes 50. Shift + right-click removes all dots for that faction.</span></div>`;
      }
      for (let i = 0; i < factions; i++) {
        const swatch = statsEl.children[i]?.querySelector('.faction-swatch');
        if (swatch) swatch.style.color = getFactionColor(i);
        const percent = total ? Math.round((counts[i] / total) * 100) : 0;
        statsEl.children[i].querySelector('.count').textContent = `${counts[i]} (${percent}%)`;
      }
      const totalEl = statsEl.querySelector('.total .count');
      if (totalEl) totalEl.textContent = total;
      const fpsEl = statsEl.querySelector('.fps .count');
      if (fpsEl) fpsEl.textContent = Math.round(fps);
    }

    function loop(timestamp) {
      const hidden = document.hidden;
      if (hidden) {
        lastFrameTime = timestamp;
        lastSimulationTime = timestamp;
        needsRender = false;
        requestAnimationFrame(loop);
        return;
      }
      targetFps = document.hasFocus() ? 60 : 40;
      const targetFrameMs = 1000 / targetFps;
      const simDeltaMs = timestamp - lastSimulationTime;
      if (!paused && simDeltaMs >= targetFrameMs) {
        const dt = Math.min(32, timestamp - lastTime) / 16.67;
        lastTime = timestamp;
        update(dt);
        lastSimulationTime = timestamp;
        if (lastFrameTime) {
          const frameMs = timestamp - lastFrameTime;
          if (frameMs > 0) {
            const currentFps = 1000 / frameMs;
            fps = fps ? fps * 0.9 + currentFps * 0.1 : currentFps;
          }
        }
        lastFrameTime = timestamp;
      } else if (paused) {
        lastTime = timestamp;
        lastSimulationTime = timestamp;
      }
      if (!paused || needsRender) {
        render();
        needsRender = false;
      }
      if (timestamp >= nextStatsUpdate) {
        updateStats();
        nextStatsUpdate = timestamp + 250;
      }
      requestAnimationFrame(loop);
    }

    controls.restart.addEventListener('click', () => {
      init();
      needsRender = true;
    });
    controls.pause.addEventListener('click', () => {
      paused = !paused;
      controls.pause.textContent = paused ? '‚ñ∂' : '‚è∏';
      controls.pause.setAttribute('aria-label', paused ? 'Resume' : 'Pause');
      controls.pause.setAttribute('title', paused ? 'Resume' : 'Pause');
      dotMenu.style.display = 'none';
      dotColorList.style.display = 'none';
      menuDot = null;
      needsRender = true;
    });
    controlsToggle.addEventListener('click', () => {
      const collapsed = document.body.classList.toggle('controls-collapsed');
      controlsToggle.setAttribute('aria-expanded', String(!collapsed));
      resizeCanvas();
      needsRender = true;
    });
    controls.fullscreen.addEventListener('click', () => {
      fullscreen = true;
      mouse.active = false;
      dotMenu.style.display = 'none';
      dotColorList.style.display = 'none';
      menuDot = null;
      document.body.classList.add('fullscreen');
      resizeCanvas();
      needsRender = true;
    });
    function removeFactionDots(faction, count) {
      let removed = 0;
      for (let i = dots.length - 1; i >= 0; i--) {
        if (dots[i].faction !== faction) continue;
        dots.splice(i, 1);
        removed++;
        if (count && removed >= count) break;
      }
    }

    document.getElementById('stats').addEventListener('click', (event) => {
      const button = event.target.closest('button[data-faction]');
      if (!button) return;
      const faction = Number(button.dataset.faction);
      const minSize = Number(controls.minSize.value);
      const maxSize = Number(controls.maxSize.value);
        if (event.shiftKey) {
          for (const dot of dots) {
            dot.faction = faction;
          }
          needsRender = true;
          return;
        }
      for (let j = 0; j < 50; j++) {
        const newX = rand(arenaPadding.left, viewWidth - arenaPadding.right);
        const newY = rand(arenaPadding.top, viewHeight - arenaPadding.bottom);
        dots.push(spawnDot(faction, newX, newY, minSize, maxSize));
      }
      needsRender = true;
    });
    document.getElementById('stats').addEventListener('contextmenu', (event) => {
      const button = event.target.closest('button[data-faction]');
      if (!button) return;
      event.preventDefault();
      const faction = Number(button.dataset.faction);
      if (event.shiftKey) {
        removeFactionDots(faction);
      } else {
        removeFactionDots(faction, 50);
      }
      needsRender = true;
    });
    canvas.addEventListener('click', (event) => {
      if (fullscreen) {
        exitFullscreen();
        return;
      }
      dotMenu.style.display = 'none';
      dotColorList.style.display = 'none';
      menuDot = null;
      const rect = canvas.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;
      for (let i = dots.length - 1; i >= 0; i--) {
        const dot = dots[i];
        const dx = x - dot.x;
        const dy = y - dot.y;
        if (dx * dx + dy * dy <= dot.size * dot.size) {
          const minSize = Number(controls.minSize.value);
          const maxSize = Number(controls.maxSize.value);
          for (let j = 0; j < 50; j++) {
            const offsetX = rand(-dot.size, dot.size);
            const offsetY = rand(-dot.size, dot.size);
            const newX = Math.max(arenaPadding.left, Math.min(viewWidth - arenaPadding.right, dot.x + offsetX));
            const newY = Math.max(arenaPadding.top, Math.min(viewHeight - arenaPadding.bottom, dot.y + offsetY));
            dots.push(spawnDot(dot.faction, newX, newY, minSize, maxSize));
          }
          needsRender = true;
          break;
        }
      }
    });
    canvas.addEventListener('mousemove', (event) => {
      if (fullscreen) return;
      const rect = canvas.getBoundingClientRect();
      mouse.x = event.clientX - rect.left;
      mouse.y = event.clientY - rect.top;
      mouse.active = true;
      if (paused) {
        hoverDot = null;
        for (let i = dots.length - 1; i >= 0; i--) {
          const dot = dots[i];
          const dx = mouse.x - dot.x;
          const dy = mouse.y - dot.y;
          if (dx * dx + dy * dy <= dot.size * dot.size) {
            hoverDot = dot;
            break;
          }
        }
        needsRender = true;
      }
    });
    canvas.addEventListener('mouseleave', () => {
      mouse.active = false;
      if (paused && hoverDot) {
        hoverDot = null;
        needsRender = true;
      }
    });
            document.addEventListener('keydown', () => {
              if (fullscreen) {
                exitFullscreen();
              }
              dotMenu.style.display = 'none';
              dotColorList.style.display = 'none';
              menuDot = null;
              needsRender = true;
            });
            document.addEventListener('mousedown', () => {
              if (fullscreen) {
                exitFullscreen();
              }
              if (!dotMenu.contains(event.target)) {
                dotMenu.style.display = 'none';
                dotColorList.style.display = 'none';
                menuDot = null;
                needsRender = true;
              }
            });

            dotSizeInput.addEventListener('input', () => {
              if (!menuDot) return;
              const size = Number(dotSizeInput.value);
              menuDot.size = size;
              dotSizeVal.textContent = size;
              needsRender = true;
            });
    dotColorButton.addEventListener('click', () => {
      dotColorList.style.display = dotColorList.style.display === 'grid' ? 'none' : 'grid';
    });
    dotColorList.addEventListener('click', (event) => {
      const swatch = event.target.closest('.dot-color-swatch');
      if (!swatch || !menuDot) return;
      menuDot.faction = Number(swatch.dataset.color);
      dotColorButton.style.background = getFactionColor(menuDot.faction);
      dotColorList.style.display = 'none';
      needsRender = true;
    });
    paletteRows.addEventListener('input', (event) => {
      const input = event.target.closest('.palette-color');
      if (!input) return;
      const index = Number(input.dataset.index);
      const normalized = normalizeHex(input.value);
      if (!normalized) return;
      palette[index] = normalized;
      const row = input.closest('.palette-row');
      const hexLabel = row?.querySelector('.palette-hex');
      if (hexLabel) hexLabel.textContent = normalized;
      if (menuDot) {
        dotColorButton.style.background = getFactionColor(menuDot.faction);
      }
      updateDotColorList();
      needsRender = true;
    });
    paletteRows.addEventListener('click', (event) => {
      const addDotsButton = event.target.closest('.palette-add-dots');
      if (addDotsButton) {
        const faction = Number(addDotsButton.dataset.index);
        const minSize = Number(controls.minSize.value);
        const maxSize = Number(controls.maxSize.value);
        for (let j = 0; j < 50; j++) {
          const newX = rand(arenaPadding.left, viewWidth - arenaPadding.right);
          const newY = rand(arenaPadding.top, viewHeight - arenaPadding.bottom);
          dots.push(spawnDot(faction, newX, newY, minSize, maxSize));
        }
        needsRender = true;
        return;
      }
      const removeButton = event.target.closest('.palette-remove');
      if (!removeButton) return;
      const index = Number(removeButton.dataset.index);
      dots = dots.filter((dot) => dot.faction !== index);
      for (const dot of dots) {
        if (dot.faction > index) dot.faction -= 1;
      }
      if (menuDot) {
        if (menuDot.faction === index) {
          dotMenu.style.display = 'none';
          dotColorList.style.display = 'none';
          menuDot = null;
        } else if (menuDot.faction > index) {
          menuDot.faction -= 1;
          dotColorButton.style.background = getFactionColor(menuDot.faction);
        }
      }
      const nextPalette = palette.filter((_, i) => i !== index);
      applyPalette(nextPalette);
      needsRender = true;
    });
    addColorButton.addEventListener('click', () => {
      applyPalette([...palette, '#ffffff']);
      needsRender = true;
    });
    clearPaletteButton.addEventListener('click', () => {
      applyPalette([]);
      needsRender = true;
    });
    randomizePaletteButton.addEventListener('click', () => {
      randomizePalette();
      needsRender = true;
    });
    resetPaletteButton.addEventListener('click', () => {
      applyPalette([...defaultPalette]);
      needsRender = true;
    });
    exportPaletteButton.addEventListener('click', async () => {
      const json = JSON.stringify(palette, null, 2);
      try {
        await navigator.clipboard.writeText(json);
      } catch (error) {
        paletteInput.value = json;
      }
    });
    savePaletteButton.addEventListener('click', () => {
      const name = paletteNameInput.value.trim() || `Palette ${new Date().toLocaleString()}`;
      const favorites = getFavorites();
      favorites.push({ name, colors: [...palette] });
      saveFavorites(favorites);
      refreshFavoritesSelect(favorites);
      paletteNameInput.value = '';
    });
    loadFavoriteButton.addEventListener('click', () => {
      const favorites = getFavorites();
      const index = Number(favoritesSelect.value);
      const selected = favorites[index];
      if (!selected) return;
      applyPalette(selected.colors.map((color) => normalizeHex(color)).filter(Boolean));
      needsRender = true;
    });
    deleteFavoriteButton.addEventListener('click', () => {
      const favorites = getFavorites();
      const index = Number(favoritesSelect.value);
      if (!Number.isFinite(index)) return;
      favorites.splice(index, 1);
      saveFavorites(favorites);
      refreshFavoritesSelect(favorites);
    });
    loadPaletteButton.addEventListener('click', () => {
      const loaded = parsePaletteInput(paletteInput.value);
      if (!loaded.length) return;
      applyPalette(loaded);
      needsRender = true;
    });
    canvas.addEventListener('contextmenu', (event) => {
      if (!paused || fullscreen) return;
      event.preventDefault();
              const rect = canvas.getBoundingClientRect();
              const x = event.clientX - rect.left;
              const y = event.clientY - rect.top;
              let target = null;
              for (let i = dots.length - 1; i >= 0; i--) {
                const dot = dots[i];
                const dx = x - dot.x;
                const dy = y - dot.y;
                if (dx * dx + dy * dy <= dot.size * dot.size) {
                  target = dot;
                  break;
                }
              }
      if (!target) {
        dotMenu.style.display = 'none';
        dotColorList.style.display = 'none';
        menuDot = null;
        return;
      }
      menuDot = target;
      dotSizeInput.value = Math.round(target.size);
      dotSizeVal.textContent = Math.round(target.size);
      dotColorButton.style.background = getFactionColor(target.faction);
      dotColorList.style.display = 'none';
      dotMenu.style.display = 'grid';
              const menuWidth = dotMenu.offsetWidth || 180;
              const menuHeight = dotMenu.offsetHeight || 120;
              const left = Math.min(viewWidth - menuWidth, Math.max(0, x));
              const top = Math.min(viewHeight - menuHeight, Math.max(0, y));
      dotMenu.style.left = `${left}px`;
      dotMenu.style.top = `${top}px`;
      needsRender = true;
    });

    init();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
